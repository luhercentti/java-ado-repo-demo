# azure-pipelines.yml
# Complete Azure DevOps CI/CD Pipeline for Java App with Terraform Infrastructure

trigger:
  branches:
    include:
    - main
    - develop

variables:
  # Maven and Java settings
  - name: mavenPomFile
    value: 'pom.xml'
  - name: javaVersion
    value: '11'
  
  # Azure Container Registry settings (will be populated by Terraform outputs)
  - name: imageRepository
    value: 'java-simple-app'
  - name: dockerfilePath
    value: 'Dockerfile'
  
  # Azure Resource settings
  - name: azureSubscription
    value: 'Azure-lhc-tests-serviceconnection'
  
  # Terraform settings
  - name: terraformVersion
    value: '1.5.7'
  - name: terraformWorkingDirectory
    value: '$(System.DefaultWorkingDirectory)/infrastructure'
  
  # Dynamic variables
  - name: imageTag
    value: '$(Build.BuildId)'

stages:
# ===== INFRASTRUCTURE SETUP STAGE =====
- stage: Infrastructure
  displayName: 'Setup Infrastructure with Terraform'
  jobs:
  - job: TerraformPlan
    displayName: 'Terraform Plan'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: TerraformInstaller@0
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: '$(terraformVersion)'
    
    - task: TerraformInstaller@0
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: '$(terraformVersion)'
    
    - task: AzureCLI@2
      displayName: 'Terraform Init and Plan'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "=== Terraform Infrastructure Planning ==="
          cd $(terraformWorkingDirectory)
          
          # Initialize Terraform
          echo "Initializing Terraform..."
          terraform init
          
          # Validate Terraform configuration
          echo "Validating Terraform configuration..."
          terraform validate
          
          # Create Terraform plan
          echo "Creating Terraform plan..."
          terraform plan -out=tfplan -detailed-exitcode
          
          # Save plan status
          PLAN_EXIT_CODE=$?
          echo "##vso[task.setvariable variable=terraformPlanExitCode]$PLAN_EXIT_CODE"
          
          if [ $PLAN_EXIT_CODE -eq 1 ]; then
            echo "‚ùå Terraform plan failed"
            exit 1
          elif [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "‚úÖ Terraform plan completed - changes detected"
          else
            echo "‚úÖ Terraform plan completed - no changes needed"
          fi
    
    # Store terraform plan as artifact
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Terraform Plan'
      inputs:
        targetPath: '$(terraformWorkingDirectory)'
        artifact: 'terraform-plan'
        publishLocation: 'pipeline'

  - job: TerraformApply
    displayName: 'Terraform Apply'
    dependsOn: TerraformPlan
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: 'Download Terraform Plan'
      inputs:
        artifactName: 'terraform-plan'
        downloadPath: '$(System.DefaultWorkingDirectory)'
    
    - task: TerraformInstaller@0
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: '$(terraformVersion)'
    
    - task: AzureCLI@2
      displayName: 'Terraform Apply'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "=== Terraform Infrastructure Deployment ==="
          cd infrastructure
          
          # Apply Terraform plan
          echo "Applying Terraform configuration..."
          terraform apply -auto-approve tfplan
          
          # Get outputs and set pipeline variables
          echo "Getting Terraform outputs..."
          ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
          ACR_NAME=$(terraform output -raw acr_name)
          
          echo "Setting pipeline variables..."
          echo "##vso[task.setvariable variable=containerRegistry;isOutput=true]$ACR_LOGIN_SERVER"
          echo "##vso[task.setvariable variable=acrName;isOutput=true]$ACR_NAME"
          echo "##vso[task.setvariable variable=imageName;isOutput=true]$ACR_LOGIN_SERVER/$(imageRepository):$(imageTag)"
          
          echo "=== Infrastructure Deployment Complete ==="
          echo "ACR Login Server: $ACR_LOGIN_SERVER"
          echo "ACR Name: $ACR_NAME"
      name: 'terraformOutputs'

# ===== BUILD AND TEST STAGE =====
- stage: Build
  displayName: 'Build, Test & Containerize'
  dependsOn: Infrastructure
  variables:
    - name: containerRegistry
      value: $[ stageDependencies.Infrastructure.TerraformApply.outputs['terraformOutputs.containerRegistry'] ]
    - name: acrName
      value: $[ stageDependencies.Infrastructure.TerraformApply.outputs['terraformOutputs.acrName'] ]
    - name: imageName
      value: $[ stageDependencies.Infrastructure.TerraformApply.outputs['terraformOutputs.imageName'] ]
  jobs:
  - job: BuildAndTest
    displayName: 'Build Java App and Create Container'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    # Checkout code
    - checkout: self
      displayName: 'Checkout Repository'
    
    # Set up Java
    - task: JavaToolInstaller@0
      displayName: 'Install Java $(javaVersion)'
      inputs:
        versionSpec: '$(javaVersion)'
        jdkArchitectureOption: 'x64'
        jdkSourceOption: 'PreInstalled'
    
    # Cache Maven dependencies
    - task: Cache@2
      displayName: 'Cache Maven Dependencies'
      inputs:
        key: 'maven | "$(Agent.OS)" | **/pom.xml'
        restoreKeys: |
          maven | "$(Agent.OS)"
        path: $(MAVEN_CACHE_FOLDER)
      env:
        MAVEN_CACHE_FOLDER: $(Pipeline.Workspace)/.m2/repository
    
    # Maven: Clean, compile, test, package
    - task: Maven@3
      displayName: 'Maven: Clean Compile Test Package'
      inputs:
        mavenPomFile: '$(mavenPomFile)'
        goals: 'clean compile test package'
        options: '-B -DskipTests=false'
        publishJUnitResults: true
        testResultsFiles: '**/surefire-reports/TEST-*.xml'
        codeCoverageToolOption: 'JaCoCo'
    
    # Build and push Docker image
    - task: AzureCLI@2
      displayName: 'Build and Push Docker Image'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "=== Building and Pushing Docker Image ==="
          echo "ACR Name: $(acrName)"
          echo "Container Registry: $(containerRegistry)"
          echo "Image Name: $(imageName)"
          
          # Login to ACR
          az acr login --name $(acrName)
          
          # Build Docker image
          echo "Building Docker image: $(imageName)"
          docker build -t $(imageName) -f $(dockerfilePath) .
          
          # Tag with latest as well
          docker tag $(imageName) $(containerRegistry)/$(imageRepository):latest
          
          # Push both tags
          echo "Pushing Docker image to ACR..."
          docker push $(imageName)
          docker push $(containerRegistry)/$(imageRepository):latest
          
          echo "Docker image pushed successfully!"
          echo "Image: $(imageName)"

# ===== DEPLOY TO DEVELOPMENT =====
- stage: Deploy_Development
  displayName: 'Deploy to Development'
  dependsOn: 
    - Infrastructure
    - Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
  variables:
    - name: containerRegistry
      value: $[ stageDependencies.Infrastructure.TerraformApply.outputs['terraformOutputs.containerRegistry'] ]
    - name: imageName
      value: $[ stageDependencies.Infrastructure.TerraformApply.outputs['terraformOutputs.imageName'] ]
  jobs:
  - deployment: DeployToDev
    displayName: 'Deploy to Dev Environment'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'development'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
            displayName: 'Checkout Repository'
          
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: '$(terraformVersion)'
          
          - task: AzureCLI@2
            displayName: 'Update Container App Image - DEV'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "=== Updating Development Container App ==="
                cd infrastructure
                
                # Initialize Terraform
                terraform init
                
                # Update container app with new image
                terraform apply -auto-approve -var-file="dev.tfvars"
                
                # Get the application URL
                DEV_APP_URL=$(terraform output -raw dev_container_app_url)
                echo "##vso[task.setvariable variable=appUrl]$DEV_APP_URL"
                echo "=== Development Application Updated Successfully! ==="
                echo "DEV URL: $DEV_APP_URL"

# ===== DEPLOY TO PRODUCTION =====
- stage: Deploy_Production
  displayName: 'Deploy to Production'
  dependsOn: 
    - Infrastructure
    - Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  variables:
    - name: containerRegistry
      value: $[ stageDependencies.Infrastructure.TerraformApply.outputs['terraformOutputs.containerRegistry'] ]
    - name: imageName
      value: $[ stageDependencies.Infrastructure.TerraformApply.outputs['terraformOutputs.imageName'] ]
  jobs:
  - deployment: DeployToProd
    displayName: 'Deploy to Production Environment'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
            displayName: 'Checkout Repository'
          
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: '$(terraformVersion)'
          
          - task: AzureCLI@2
            displayName: 'Update Container App Image - PRODUCTION'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "=== Updating Production Container App ==="
                cd infrastructure
                
                # Initialize Terraform
                terraform init
                
                # Update container app with new image
                terraform apply -auto-approve -var-file="prod.tfvars"
                
                # Get the application URL
                PROD_APP_URL=$(terraform output -raw prod_container_app_url)
                echo "##vso[task.setvariable variable=appUrl]$PROD_APP_URL"
                echo "=== Production Application Updated Successfully! ==="
                echo "PROD URL: $PROD_APP_URL"
          
          # Run smoke tests against production
          - script: |
              echo "=== Running production smoke tests ==="
              # Add your smoke tests here
              # curl -f $(appUrl)/health || exit 1
              echo "Smoke tests passed!"
            displayName: 'Production Smoke Tests'

# ===== WAIT AND CLEANUP STAGE =====
- stage: WaitAndCleanup
  displayName: 'Wait 5 Minutes Then Cleanup Resources'
  dependsOn: 
    - Deploy_Development
    - Deploy_Production
  condition: always()  # Run cleanup even if deployments fail
  jobs:
  - job: WaitJob
    displayName: 'Wait 5 Minutes'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        echo "=== Waiting 5 minutes before cleanup ==="
        echo "This gives time to test the deployed applications"
        echo "Start time: $(date)"
        
        # Wait for 5 minutes (300 seconds)
        sleep 300
        
        echo "Wait complete at: $(date)"
        echo "Proceeding to cleanup..."
      displayName: 'Wait 5 Minutes'
  
  - job: TerraformDestroy
    displayName: 'Terraform Destroy All Resources'
    dependsOn: WaitJob
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self


    - task: AzureCLI@2
      displayName: 'Terraform Destroy All Resources'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "=== STARTING TERRAFORM DESTROY ==="
          echo "Cleanup started at: $(date)"
          cd infrastructure
          
          # Initialize Terraform
          echo "Initializing Terraform..."
          terraform init
          
          # Show what will be destroyed
          echo "Planning destruction..."
          terraform plan -destroy -out=destroy.tfplan
          
          # Destroy all resources
          echo "Destroying all resources..."
          terraform apply -auto-approve destroy.tfplan
          
          echo "=== TERRAFORM DESTROY COMPLETE ==="
          echo "All resources have been destroyed successfully"
          echo "Cleanup completion time: $(date)"
          
          echo ""
          echo "=== SUMMARY ==="
          echo "‚úÖ Infrastructure created and applications deployed"
          echo "‚úÖ Applications ran for 5 minutes"
          echo "‚úÖ All resources destroyed via Terraform"
          echo "üí∞ No ongoing Azure costs"
          echo ""
          echo "Resources destroyed:"
          echo "- Azure Container Registry and all images"
          echo "- Container Apps (dev and prod)"
          echo "- Container Apps Environments"
          echo "- Log Analytics Workspace"
          echo "- All Resource Groups"
          echo "- All associated networking and compute resources"displayName: 'Checkout Repository'
    
